{
  "manifest": {
    "name": "yup",
    "version": "0.27.0",
    "description": "Dead simple Object schema validation",
    "main": "lib/index.js",
    "runkitExampleFilename": "./runkit-example.js",
    "scripts": {
      "test": "npm run lint && npm run test-all -- --runInBand",
      "testonly": "jest",
      "test-all": "npm run testonly -- --projects ./jest-sync.config.json --projects ./package.json",
      "tdd": "jest --watch",
      "lint": "eslint src test",
      "precommit": "lint-staged",
      "toc": "doctoc README.md --github",
      "release": "rollout",
      "build": "babel src --out-dir lib --delete-dir-on-start && npm run toc",
      "prepublishOnly": "npm run build"
    },
    "files": [
      "lib"
    ],
    "repository": {
      "type": "git",
      "url": "https://github.com/jquense/yup.git"
    },
    "author": {
      "name": "@monasticpanic Jason Quense"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/jquense/yup/issues"
    },
    "homepage": "https://github.com/jquense/yup",
    "release": {
      "conventional-commits": true
    },
    "prettier": {
      "singleQuote": true,
      "trailingComma": "all"
    },
    "lint-staged": {
      "*.{js,json,css,md}": [
        "prettier --write",
        "git add"
      ]
    },
    "jest": {
      "globals": {
        "YUP_USE_SYNC": true
      },
      "testEnvironment": "node",
      "setupTestFrameworkScriptFile": "./test-setup.js",
      "roots": [
        "test"
      ],
      "testRegex": "\\.js",
      "testPathIgnorePatterns": [
        "helpers\\.js"
      ]
    },
    "devDependencies": {
      "@4c/rollout": "^1.3.3",
      "@babel/cli": "7.2.3",
      "@babel/core": "7.3.4",
      "babel-core": "^7.0.0-bridge.0",
      "babel-eslint": "^9.0.0",
      "babel-jest": "^22.4.3",
      "babel-preset-jason": "^6.0.1",
      "benchmark": "^2.0.0",
      "chai": "^4.2.0",
      "chai-as-promised": "^7.1.1",
      "dirty-chai": "^2.0.1",
      "doctoc": "^1.4.0",
      "eslint": "^4.19.1",
      "eslint-config-jason": "^4.0.1",
      "eslint-config-prettier": "^3.0.1",
      "eslint-plugin-import": "^2.16.0",
      "eslint-plugin-jest": "^21.22.0",
      "eslint-plugin-react": "^7.12.4",
      "husky": "^0.14.3",
      "jest": "^22.4.3",
      "lint-staged": "^7.2.2",
      "prettier": "^1.13.7",
      "rollup": "^0.65.0",
      "rollup-plugin-babel": "^4.0.2",
      "rollup-plugin-filesize": "^4.0.1",
      "rollup-plugin-node-resolve": "^3.3.0",
      "rollup-plugin-size-snapshot": "^0.6.1",
      "sinon": "^6.1.5",
      "sinon-chai": "^3.3.0"
    },
    "dependencies": {
      "@babel/runtime": "^7.0.0",
      "fn-name": "~2.0.1",
      "lodash": "^4.17.11",
      "property-expr": "^1.5.0",
      "synchronous-promise": "^2.0.6",
      "toposort": "^2.0.2"
    },
    "_registry": "npm",
    "_loc": "/home/senmioxl/.cache/yarn/v6/npm-yup-0.27.0-f8cb198c8e7dd2124beddc2457571329096b06e7-integrity/node_modules/yup/package.json",
    "readmeFilename": "README.md",
    "readme": "# Yup\n\nYup is a JavaScript object schema validator and object parser. The API and style is ~~stolen~~ heavily inspired\nby [Joi](https://github.com/hapijs/joi), which is an amazing library but is generally too large and difficult\nto package for use in a browser. Yup is leaner: in the same spirit, without some of the fancy features.\nYou can use it on the server as well, but in that case you might as well just use Joi.\n\nYup is also a good bit less opinionated than joi, allowing for custom transformations and async validation.\nIt also allows \"stacking\" conditions via `when` for properties that depend on more than one other sibling or\nchild property. Yup separates the parsing and validating functions into separate steps so it can be used to parse\njson separate from validating it, via the `cast` method.\n\n**Try it out:** https://runkit.com/jquense/yup#\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n\n- [Install](#install)\n- [Usage](#usage)\n  - [Using a custom locale dictionary](#using-a-custom-locale-dictionary)\n- [API](#api)\n  - [`yup`](#yup)\n    - [`yup.reach(schema: Schema, path: string, value?: object, context?: object): Schema`](#yupreachschema-schema-path-string-value-object-context-object-schema)\n    - [`yup.addMethod(schemaType: Schema, name: string, method: ()=> Schema): void`](#yupaddmethodschematype-schema-name-string-method--schema-void)\n    - [`yup.ref(path: string, options: { contextPrefix: string }): Ref`](#yuprefpath-string-options--contextprefix-string--ref)\n    - [`yup.lazy((value: any) => Schema): Lazy`](#yuplazyvalue-any--schema-lazy)\n    - [`ValidationError(errors: string | Array<string>, value: any, path: string)`](#validationerrorerrors-string--arraystring-value-any-path-string)\n  - [mixed](#mixed)\n    - [`mixed.clone(): Schema`](#mixedclone-schema)\n    - [`mixed.label(label: string): Schema`](#mixedlabellabel-string-schema)\n    - [`mixed.meta(metadata: object): Schema`](#mixedmetametadata-object-schema)\n    - [`mixed.describe(): SchemaDescription`](#mixeddescribe-schemadescription)\n    - [`mixed.concat(schema: Schema)`](#mixedconcatschema-schema)\n    - [`mixed.validate(value: any, options?: object): Promise<any, ValidationError>`](#mixedvalidatevalue-any-options-object-promiseany-validationerror)\n    - [`mixed.validateSync(value: any, options?: object): any`](#mixedvalidatesyncvalue-any-options-object-any)\n    - [`mixed.validateAt(path: string, value: any, options?: object): Promise<any, ValidationError>`](#mixedvalidateatpath-string-value-any-options-object-promiseany-validationerror)\n    - [`mixed.validateSyncAt(path: string, value: any, options?: object): any`](#mixedvalidatesyncatpath-string-value-any-options-object-any)\n    - [`mixed.isValid(value: any, options?: object): Promise<boolean>`](#mixedisvalidvalue-any-options-object-promiseboolean)\n    - [`mixed.isValidSync(value: any, options?: object): boolean`](#mixedisvalidsyncvalue-any-options-object-boolean)\n    - [`mixed.cast(value: any, options = {}): any`](#mixedcastvalue-any-options---any)\n    - [`mixed.isType(value: any): boolean`](#mixedistypevalue-any-boolean)\n    - [`mixed.strict(isStrict: boolean = false): Schema`](#mixedstrictisstrict-boolean--false-schema)\n    - [`mixed.strip(stripField: boolean = true): Schema`](#mixedstripstripfield-boolean--true-schema)\n    - [`mixed.withMutation(builder: (current: Schema) => void): void`](#mixedwithmutationbuilder-current-schema--void-void)\n    - [`mixed.default(value: any): Schema`](#mixeddefaultvalue-any-schema)\n    - [`mixed.default(): Any`](#mixeddefault-any)\n    - [`mixed.nullable(isNullable: boolean = true): Schema`](#mixednullableisnullable-boolean--true-schema)\n    - [`mixed.required(message?: string | function): Schema`](#mixedrequiredmessage-string--function-schema)\n    - [`mixed.notRequired(): Schema`](#mixednotrequired-schema)\n    - [`mixed.typeError(message: string): Schema`](#mixedtypeerrormessage-string-schema)\n    - [`mixed.oneOf(arrayOfValues: Array<any>, message?: string | function): Schema` Alias: `equals`](#mixedoneofarrayofvalues-arrayany-message-string--function-schema-alias-equals)\n    - [`mixed.notOneOf(arrayOfValues: Array<any>, message?: string | function)`](#mixednotoneofarrayofvalues-arrayany-message-string--function)\n    - [`mixed.when(keys: string | Array<string>, builder: object | (value, schema)=> Schema): Schema`](#mixedwhenkeys-string--arraystring-builder-object--value-schema-schema-schema)\n    - [`mixed.test(name: string, message: string | function, test: function): Schema`](#mixedtestname-string-message-string--function-test-function-schema)\n    - [`mixed.test(options: object): Schema`](#mixedtestoptions-object-schema)\n    - [`mixed.transform((currentValue: any, originalValue: any) => any): Schema`](#mixedtransformcurrentvalue-any-originalvalue-any--any-schema)\n  - [string](#string)\n    - [`string.required(message?: string | function): Schema`](#stringrequiredmessage-string--function-schema)\n    - [`string.length(limit: number | Ref, message?: string | function): Schema`](#stringlengthlimit-number--ref-message-string--function-schema)\n    - [`string.min(limit: number | Ref, message?: string | function): Schema`](#stringminlimit-number--ref-message-string--function-schema)\n    - [`string.max(limit: number | Ref, message?: string | function): Schema`](#stringmaxlimit-number--ref-message-string--function-schema)\n    - [`string.matches(regex: Regex, message?: string | function): Schema`](#stringmatchesregex-regex-message-string--function-schema)\n    - [`string.matches(regex: Regex, options: { message: string, excludeEmptyString: bool }): Schema`](#stringmatchesregex-regex-options--message-string-excludeemptystring-bool--schema)\n    - [`string.email(message?: string | function): Schema`](#stringemailmessage-string--function-schema)\n    - [`string.url(message?: string | function): Schema`](#stringurlmessage-string--function-schema)\n    - [`string.ensure(): Schema`](#stringensure-schema)\n    - [`string.trim(message?: string | function): Schema`](#stringtrimmessage-string--function-schema)\n    - [`string.lowercase(message?: string | function): Schema`](#stringlowercasemessage-string--function-schema)\n    - [`string.uppercase(message?: string | function): Schema`](#stringuppercasemessage-string--function-schema)\n  - [number](#number)\n    - [`number.min(limit: number | Ref, message?: string | function): Schema`](#numberminlimit-number--ref-message-string--function-schema)\n    - [`number.max(limit: number | Ref, message?: string | function): Schema`](#numbermaxlimit-number--ref-message-string--function-schema)\n    - [`number.lessThan(max: number | Ref, message?: string | function): Schema`](#numberlessthanmax-number--ref-message-string--function-schema)\n    - [`number.moreThan(min: number | Ref, message?: string | function): Schema`](#numbermorethanmin-number--ref-message-string--function-schema)\n    - [`number.positive(message?: string | function): Schema`](#numberpositivemessage-string--function-schema)\n    - [`number.negative(message?: string | function): Schema`](#numbernegativemessage-string--function-schema)\n    - [`number.integer(message?: string | function): Schema`](#numberintegermessage-string--function-schema)\n    - [`number.truncate(): Schema`](#numbertruncate-schema)\n    - [`number.round(type: 'floor' | 'ceil' | 'trunc' | 'round' = 'round'): Schema`](#numberroundtype-floor--ceil--trunc--round--round-schema)\n  - [boolean](#boolean)\n  - [date](#date)\n    - [`date.min(limit: Date | string | Ref, message?: string | function): Schema`](#dateminlimit-date--string--ref-message-string--function-schema)\n    - [`date.max(limit: Date | string | Ref, message?: string | function): Schema`](#datemaxlimit-date--string--ref-message-string--function-schema)\n  - [array](#array)\n    - [`array.of(type: Schema): Schema`](#arrayoftype-schema-schema)\n    - [`array.required(message?: string | function): Schema`](#arrayrequiredmessage-string--function-schema)\n    - [`array.min(limit: number | Ref, message?: string | function): Schema`](#arrayminlimit-number--ref-message-string--function-schema)\n    - [`array.max(limit: number | Ref, message?: string | function): Schema`](#arraymaxlimit-number--ref-message-string--function-schema)\n    - [`array.ensure(): Schema`](#arrayensure-schema)\n    - [`array.compact(rejector: (value) => boolean): Schema`](#arraycompactrejector-value--boolean-schema)\n  - [object](#object)\n    - [`object.shape(fields: object, noSortEdges?: Array<[string, string]>): Schema`](#objectshapefields-object-nosortedges-arraystring-string-schema)\n    - [`object.from(fromKey: string, toKey: string, alias: boolean = false): Schema`](#objectfromfromkey-string-tokey-string-alias-boolean--false-schema)\n    - [`object.noUnknown(onlyKnownKeys: boolean = true, message?: string | function): Schema`](#objectnounknownonlyknownkeys-boolean--true-message-string--function-schema)\n    - [`object.camelCase(): Schema`](#objectcamelcase-schema)\n    - [`object.constantCase(): Schema`](#objectconstantcase-schema)\n- [Extending Schema Types](#extending-schema-types)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n## Install\n\n```sh\nnpm install -S yup\n```\n\nYup always relies on the `Promise` global object to handle asynchronous values as well as `Set` and `Map`.\nFor browsers that do not support these, you'll need to include a polyfill, such as core-js:\n\n```js\nimport 'core-js/es6/promise';\nimport 'core-js/es6/set';\nimport 'core-js/es6/map';\n```\n\n## Usage\n\nYou define and create schema objects. Schema objects are immutable, so each call of a method returns a _new_ schema object.\n\n**try it out using tonicdev! https://tonicdev.com/570c52590a85f71200eb09ba/yup**\n\nWhen using es module syntax, yup exports everything as a named export\n\n```js\nimport * as yup from 'yup'; // for everything\n// or\nimport { string, object } from 'yup'; // for only what you need\n```\n\n```js\nlet yup = require('yup');\n\nlet schema = yup.object().shape({\n  name: yup.string().required(),\n  age: yup\n    .number()\n    .required()\n    .positive()\n    .integer(),\n  email: yup.string().email(),\n  website: yup.string().url(),\n  createdOn: yup.date().default(function() {\n    return new Date();\n  }),\n});\n\n// check validity\nschema\n  .isValid({\n    name: 'jimmy',\n    age: 24,\n  })\n  .then(function(valid) {\n    valid; // => true\n  });\n\n// you can try and type cast objects to the defined schema\nschema.cast({\n  name: 'jimmy',\n  age: '24',\n  createdOn: '2014-09-23T19:25:25Z',\n});\n// => { name: 'jimmy', age: 24, createdOn: Date }\n```\n\n> If you're looking for an easily serializable DSL for yup schema, check out [yup-ast](https://github.com/WASD-Team/yup-ast)\n\n### Using a custom locale dictionary\n\nAllows you to customize the default messages used by Yup, when no message is provided with a validation test.\nIf any message is missing in the custom dictionary the error message will default to Yup's one.\n\n```js\nimport { setLocale } from 'yup';\n\nsetLocale({\n  mixed: {\n    default: 'Não é válido',\n  },\n  number: {\n    min: 'Deve ser maior que ${min}',\n  },\n});\n\n// now use Yup schemas AFTER you defined your custom dictionary\nlet schema = yup.object().shape({\n  name: yup.string(),\n  age: yup.number().min(18),\n});\n\nschema.validate({ name: 'jimmy', age: 11 }).catch(function(err) {\n  err.name; // => 'ValidationError'\n  err.errors; // => ['Deve ser maior que 18']\n});\n```\n\n## API\n\n### `yup`\n\nThe module export.\n\n```js\nlet yup = require('yup');\n\nyup.mixed;\nyup.string;\nyup.number;\nyup.boolean; // also aliased as yup.bool\nyup.date;\nyup.object;\nyup.array;\n\nyup.reach;\nyup.addMethod;\nyup.ref;\nyup.lazy;\nyup.setLocale;\nyup.ValidationError;\n```\n\n#### `yup.reach(schema: Schema, path: string, value?: object, context?: object): Schema`\n\nFor nested schema's `yup.reach` will retrieve a nested schema based on the provided path.\n\nFor nested schema that need to resolve dynamically, you can provide a `value` and optionally\na `context` object.\n\n```js\nlet schema = object().shape({\n  nested: object().shape({\n    arr: array().of(object().shape({ num: number().max(4) })),\n  }),\n});\n\nreach(schema, 'nested.arr.num');\nreach(schema, 'nested.arr[].num');\nreach(schema, 'nested.arr[1].num');\nreach(schema, 'nested[\"arr\"][1].num');\n```\n\n#### `yup.addMethod(schemaType: Schema, name: string, method: ()=> Schema): void`\n\nAdds a new method to the core schema types. A friendlier convenience method for `schemaType.prototype[name] = method`.\n\n```js\nyup.addMethod(yup.date, 'format', function(formats, parseStrict) {\n  return this.transform(function(value, originalValue) {\n    if (this.isType(value)) return value;\n\n    value = Moment(originalValue, formats, parseStrict);\n\n    return date.isValid() ? date.toDate() : invalidDate;\n  });\n});\n```\n\n#### `yup.ref(path: string, options: { contextPrefix: string }): Ref`\n\nCreates a reference to another sibling or sibling descendant field. Ref's are resolved\nat _validation/cast time_ and supported where specified. Ref's are evaluated in in the proper order so that\nthe ref value is resolved before the field using the ref (be careful of circular dependencies!).\n\n```js\nlet schema = object({\n  baz: ref('foo.bar'),\n  foo: object({\n    bar: string(),\n  }),\n  x: ref('$x'),\n});\n\nschema.cast({ foo: { bar: 'boom' } }, { context: { x: 5 } });\n// => { baz: 'boom',  x: 5, foo: { bar: 'boom' } }\n```\n\n#### `yup.lazy((value: any) => Schema): Lazy`\n\nCreates a schema that is evaluated at validation/cast time. Useful for creating\nrecursive schema like Trees, for polymophic fields and arrays.\n\n**CAUTION!** When defining parent-child recursive object schema, you want to reset the `default()`\nto `undefined` on the child otherwise the object will infinitely nest itself when you cast it!.\n\n```js\nlet node = object({\n  id: number(),\n  child: yup.lazy(() => node.default(undefined)),\n});\n\nlet renderable = yup.lazy(value => {\n  switch (typeof value) {\n    case 'number':\n      return number();\n    case 'string':\n      return string();\n    default:\n      return mixed();\n  }\n});\n\nlet renderables = array().of(renderable);\n```\n\n#### `ValidationError(errors: string | Array<string>, value: any, path: string)`\n\nThrown on failed validations, with the following properties\n\n- `name`: \"ValidationError\"\n- `path`: a string, indicating where there error was thrown. `path` is empty at the root level.\n- `errors`: array of error messages\n- `inner`: in the case of aggregate errors, inner is an array of `ValidationErrors` throw earlier in the\n  validation chain. When the `abortEarly` option is `false` this is where you can inspect each error thrown,\n  alternatively `errors` will have all the of the messages from each inner error.\n\n### mixed\n\nCreates a schema that matches all types. All types inherit from this base type\n\n```js\nlet schema = yup.mixed();\n\nschema.isValid(undefined, function(valid) {\n  valid; // => true\n});\n```\n\n#### `mixed.clone(): Schema`\n\nCreates a deep copy of the schema. Clone is used internally to return a new schema with every schema state change.\n\n#### `mixed.label(label: string): Schema`\n\nOverrides the key name which is used in error messages.\n\n#### `mixed.meta(metadata: object): Schema`\n\nAdds to a metadata object, useful for storing data with a schema, that doesn't belong\nthe cast object itself.\n\n#### `mixed.describe(): SchemaDescription`\n\nCollects schema details (like meta, labels, and active tests) into a serializable\ndescription object.\n\n```\nSchemaDescription {\n  type: string,\n  label: string,\n  meta: object,\n  tests: Array<{ name: string, params: object }>\n}\n```\n\n#### `mixed.concat(schema: Schema)`\n\nCreates a new instance of the schema by combining two schemas. Only schemas of the same type can be concatenated.\n\n#### `mixed.validate(value: any, options?: object): Promise<any, ValidationError>`\n\nReturns the value (a cast value if `isStrict` is `false`) if the value is valid, and returns the errors otherwise.\nThis method is **asynchronous** and returns a Promise object, that is fulfilled with the value, or rejected\nwith a `ValidationError`.\n\nThe `options` argument is an object hash containing any schema options you may want to override\n(or specify for the first time).\n\n```js\nOptions = {\n  strict: boolean = false;\n  abortEarly: boolean = true;\n  stripUnknown: boolean = false;\n  recursive: boolean = true;\n  context?: object;\n}\n```\n\n- `strict`: only validate the input, and skip and coercion or transformation\n- `abortEarly`: return from validation methods on the first error rather\n  than after all validations run.\n- `stripUnknown`: remove unspecified keys from objects.\n- `recursive`: when `false` validations will not descend into nested schema\n  (relevant for objects or arrays).\n- `context`: any context needed for validating schema conditions (see: `when()`)\n\n```js\nschema.validate({ name: 'jimmy', age: 24 }).then(function(value) {\n  value; // => { name: 'jimmy',age: 24 }\n});\n\nschema.validate({ name: 'jimmy', age: 'hi' }).catch(function(err) {\n  err.name; // => 'ValidationError'\n  err.errors; // => ['age must be a number']\n});\n```\n\n#### `mixed.validateSync(value: any, options?: object): any`\n\nRuns validatations synchronously _if possible_ and returns the resulting value,\nor throws a ValidationError. Accepts all the same options as `validate`.\n\nSynchronous validation only works if there are no configured async tests, e.g tests that return a Promise.\nFor instance this will work:\n\n```js\nlet schema = number().test(\n  'is-42',\n  \"this isn't the number i want\",\n  value => value != 42,\n);\n\nschema.validateSync(23); // throws ValidationError\n```\n\nhowever this will not:\n\n```js\nlet schema = number().test('is-42', \"this isn't the number i want\", value =>\n  Promise.resolve(value != 42),\n);\n\nschema.validateSync(42); // throws Error\n```\n\n#### `mixed.validateAt(path: string, value: any, options?: object): Promise<any, ValidationError>`\n\nValidate a deeply nested path within the schema. Similar to how `reach` works,\nbut uses the resulting schema as the subject for validation.\n\n> Note! The `value` here is the _root_ value relative to the starting schema, not the value at the nested path.\n\n```js\nlet schema = object({\n  foo: array().of(\n    object({\n      loose: boolean(),\n      bar: string().when('loose', {\n        is: true,\n        otherwise: s => s.strict(),\n      }),\n    }),\n  ),\n});\n\nlet rootValue = {\n  foo: [{ bar: 1 }, { bar: 1, loose: true }],\n};\n\nawait schema.validateAt('foo[0].bar', rootValue); // => ValidationError: must be a string\n\nawait schema.validateAt('foo[1].bar', rootValue); // => '1'\n```\n\n#### `mixed.validateSyncAt(path: string, value: any, options?: object): any`\n\nSame as `validateAt` but synchronous.\n\n#### `mixed.isValid(value: any, options?: object): Promise<boolean>`\n\nReturns `true` when the passed in value matches the schema. `isValid`\nis **asynchronous** and returns a Promise object.\n\nTakes the same options as `validate()`.\n\n#### `mixed.isValidSync(value: any, options?: object): boolean`\n\nSynchronously returns `true` when the passed in value matches the schema.\n\nTakes the same options as `validateSync()` and has the same caveats around async tests.\n\n#### `mixed.cast(value: any, options = {}): any`\n\nAttempts to coerce the passed in value to a value that matches the schema. For example: `'5'` will\ncast to `5` when using the `number()` type. Failed casts generally return `null`, but may also\nreturn results like `NaN` and unexpected strings.\n\n`options` parameter can be an object containing `context`. (For more info on `context` see `mixed.validate`)\n\n#### `mixed.isType(value: any): boolean`\n\nRuns a type check against the passed in `value`. It returns true if it matches,\nit does not cast the value. When `nullable()` is set `null` is considered a valid value of the type.\nYou should use `isType` for all Schema type checks.\n\n#### `mixed.strict(isStrict: boolean = false): Schema`\n\nSets the `strict` option to `true`. Strict schemas skip coercion and transformation attempts,\nvalidating the value \"as is\".\n\n#### `mixed.strip(stripField: boolean = true): Schema`\n\nMarks a schema to be removed from an output object. Only works as a nested schema.\n\n```js\nlet schema = object({\n  useThis: number(),\n  notThis: string().strip(),\n});\n\nschema.cast({ notThis: 'foo', useThis: 4 }); // => { useThis: 4 }\n```\n\n#### `mixed.withMutation(builder: (current: Schema) => void): void`\n\nFirst the legally required Rich Hickey quote:\n\n> If a tree falls in the woods, does it make a sound?\n>\n> If a pure function mutates some local data in order to produce an immutable return value, is that ok?\n\n`withMutation` allows you to mutate the schema in place, instead of the default behavior which clones before each change.\nGenerally this isn't necessary since the vast majority of schema changes happen during the initial\ndeclaration, and only happen once over the lifetime of the schema, so performance isn't an issue.\nHowever certain mutations _do_ occur at cast/validation time, (such as conditional schema using `when()`), or\nwhen instantiating a schema object.\n\n```js\nobject()\n  .shape({ key: string() })\n  .withMutation(schema => {\n    return arrayOfObjectTests.forEach(test => {\n      schema.test(test);\n    });\n  });\n```\n\n#### `mixed.default(value: any): Schema`\n\nSets a default value to use when the value is `undefined`.\nDefaults are created after transformations are executed, but before validations, to help ensure that safe\ndefaults are specified. The default value will be cloned on each use, which can incur performance penalty\nfor objects and arrays. To avoid this overhead you can also pass a function that returns a new default.\nNote that `null` is considered a separate non-empty value.\n\n```js\nyup.string.default('nothing');\n\nyup.object.default({ number: 5 }); // object will be cloned every time a default is needed\n\nyup.object.default(() => ({ number: 5 })); // this is cheaper\n\nyup.date.default(() => new Date()); // also helpful for defaults that change over time\n```\n\n#### `mixed.default(): Any`\n\nCalling `default` with no arguments will return the current default value\n\n#### `mixed.nullable(isNullable: boolean = true): Schema`\n\nIndicates that `null` is a valid value for the schema. Without `nullable()`\n`null` is treated as a different type and will fail `isType()` checks.\n\n#### `mixed.required(message?: string | function): Schema`\n\nMark the schema as required. All field values apart from `undefined` and `null` meet this requirement.\n\n#### `mixed.notRequired(): Schema`\n\nMark the schema as not required. Passing `undefined` as value will not fail validation.\n\n#### `mixed.typeError(message: string): Schema`\n\nDefine an error message for failed type checks. The `${value}` and `${type}` interpolation can\nbe used in the `message` argument.\n\n#### `mixed.oneOf(arrayOfValues: Array<any>, message?: string | function): Schema` Alias: `equals`\n\nWhitelist a set of values. Values added are automatically removed from any blacklist if they are in it.\nThe `${values}` interpolation can be used in the `message` argument.\n\n```js\nlet schema = yup.mixed().oneOf(['jimmy', 42]);\n\nawait schema.isValid(42); // => true\nawait schema.isValid('jimmy'); // => true\nawait schema.isValid(new Date()); // => false\n```\n\n#### `mixed.notOneOf(arrayOfValues: Array<any>, message?: string | function)`\n\nBlacklist a set of values. Values added are automatically removed from any whitelist if they are in it.\nThe `${values}` interpolation can be used in the `message` argument.\n\n```js\nlet schema = yup.mixed().notOneOf(['jimmy', 42]);\n\nawait schema.isValid(42); // => false\nawait schema.isValid(new Date()); // => true\n```\n\n#### `mixed.when(keys: string | Array<string>, builder: object | (value, schema)=> Schema): Schema`\n\nAdjust the schema based on a sibling or sibling children fields. You can provide an object\nliteral where the key `is` is value or a matcher function, `then` provides the true schema and/or\n`otherwise` for the failure condition.\n\n`is` conditions are strictly compared (`===`) if you want to use a different form of equality you\ncan provide a function like: `is: (value) => value == true`.\n\nLike joi you can also prefix properties with `$` to specify a property that is dependent\non `context` passed in by `validate()` or `isValid`. `when` conditions are additive.\n\n```js\nlet schema = object({\n  isBig: boolean(),\n  count: number()\n    .when('isBig', {\n      is: true, // alternatively: (val) => val == true\n      then: yup.number().min(5),\n      otherwise: yup.number().min(0),\n    })\n    .when('$other', (other, schema) => (other === 4 ? schema.max(6) : schema)),\n});\n\nawait schema.validate(value, { context: { other: 4 } });\n```\n\nYou can also specify more than one dependent key, in which case each value will be spread as an argument.\n\n```js\nlet schema = object({\n  isSpecial: boolean(),\n  isBig: boolean(),\n  count: number().when(['isBig', 'isSpecial'], {\n    is: true, // alternatively: (isBig, isSpecial) => isBig && isSpecial\n    then: yup.number().min(5),\n    otherwise: yup.number().min(0),\n  }),\n});\n\nawait schema.validate({\n  isBig: true,\n  isSpecial: true,\n  count: 10,\n});\n```\n\nAlternatively you can provide a function that returns a schema\n(called with the value of the key and the current schema).\n\n```js\nlet schema = yup.object({\n  isBig: yup.boolean(),\n  count: yup.number().when('isBig', (isBig, schema) => {\n    return isBig ? schema.min(5) : schema.min(0);\n  }),\n});\n\nawait schema.validate({ isBig: false, count: 4 });\n```\n\n#### `mixed.test(name: string, message: string | function, test: function): Schema`\n\nAdds a test function to the validation chain. Tests are run after any object is cast.\nMany types have some tests built in, but you can create custom ones easily.\nIn order to allow asynchronous custom validations _all_ (or no) tests are run asynchronously.\nA consequence of this is that test execution order cannot be guaranteed.\n\nAll tests must provide a `name`, an error `message` and a validation function that must return\n`true` or `false` or a `ValidationError`. To make a test async return a promise that resolves `true`\nor `false` or a `ValidationError`.\n\nfor the `message` argument you can provide a string which is will interpolate certain values\nif specified using the `${param}` syntax. By default all test messages are passed a `path` value\nwhich is valuable in nested schemas.\n\nthe `test` function is called with the current `value`. For more advanced validations you can\nuse the alternate signature to provide more options (see below):\n\n```js\nlet jimmySchema = string().test(\n  'is-jimmy',\n  '${path} is not Jimmy',\n  value => value === 'jimmy',\n);\n\n// or make it async by returning a promise\nlet asyncJimmySchema = string().test(\n  'is-jimmy',\n  '${path} is not Jimmy',\n  async (value) => (await fetch('/is-jimmy/' + value)).responseText === 'true',\n});\n\nawait schema.isValid('jimmy'); // => true\nawait schema.isValid('john'); // => false\n```\n\ntest functions are called with a special context, or `this` value, that exposes some useful metadata and functions. Note that to use the `this` context the test function must be a function expression (`function test(value) {}`), not an arrow function, since arrow functions have lexical context.\n\n- `this.path`: the string path of the current validation\n- `this.schema`: the resolved schema object that the test is running against.\n- `this.options`: the `options` object that validate() or isValid() was called with\n- `this.parent`: in the case of nested schema, this is the value of the parent object\n- `this.createError(Object: { path: String, message: String })`: create and return a\n  validation error. Useful for dynamically setting the `path`, or more likely, the error `message`.\n  If either option is omitted it will use the current path, or default message.\n\n#### `mixed.test(options: object): Schema`\n\nAlternative `test(..)` signature. `options` is an object containing some of the following options:\n\n```js\nOptions = {\n  // unique name identifying the test\n  name: string;\n  // test function, determines schema validity\n  test: (value: any) => boolean;\n  // the validation error message\n  message: string;\n  // values passed to message for interpolation\n  params: ?object;\n  // mark the test as exclusive, meaning only one of the same can be active at once\n  exclusive: boolean = false;\n}\n```\n\nIn the case of mixing exclusive and non-exclusive tests the following logic is used.\nIf a non-exclusive test is added to a schema with an exclusive test of the same name\nthe exclusive test is removed and further tests of the same name will be stacked.\n\nIf an exclusive test is added to a schema with non-exclusive tests of the same name\nthe previous tests are removed and further tests of the same name will replace each other.\n\n```js\nlet max = 64;\nlet schema = yup.mixed().test({\n  name: 'max',\n  exclusive: true,\n  params: { max },\n  message: '${path} must be less than ${max} characters',\n  test: value => value == null || value.length <= max,\n});\n```\n\n#### `mixed.transform((currentValue: any, originalValue: any) => any): Schema`\n\nAdds a transformation to the transform chain. Transformations are central to the casting process,\ndefault transforms for each type coerce values to the specific type (as verified by [`isType()`](mixedistypevalue)).\ntransforms are run before validations and only applied when `strict` is `true`. Some types have built in transformations.\n\nTransformations are useful for arbitrarily altering how the object is cast, **however, you should take care\nnot to mutate the passed in value.** Transforms are run sequentially so each `value` represents the\ncurrent state of the cast, you can use the `originalValue` param if you need to work on the raw initial value.\n\n```js\nlet schema = string().transform(function(value, originalvalue) {\n  return this.isType(value) && value !== null ? value.toUpperCase() : value;\n});\n\nschema.cast('jimmy'); // => 'JIMMY'\n```\n\nEach types will handle basic coercion of values to the proper type for you, but occasionally\nyou may want to adjust or refine the default behavior. For example, if you wanted to use a different\ndate parsing strategy than the default one you could do that with a transform.\n\n```js\nmodule.exports = function(formats = 'MMM dd, yyyy') {\n  return date().transform(function(value, originalvalue) {\n    // check to see if the previous transform already parsed the date\n    if (this.isType(value)) return value;\n\n    // the default coercion failed so lets try it with Moment.js instead\n    value = Moment(originalValue, formats);\n\n    // if its valid return the date object, otherwise return an `InvalidDate`\n    return value.isValid() ? value.toDate() : new Date('');\n  });\n};\n```\n\n### string\n\nDefine a string schema. Supports all the same methods as [`mixed`](#mixed).\n\n```js\nlet schema = yup.string();\n\nawait schema.isValid('hello'); // => true\n```\n\nBy default, the `cast` logic of `string` is to call `toString` on the value if it exists.\nempty values are not coerced (use `ensure()` to coerce empty values to empty strings).\n\nFailed casts return the input value.\n\n#### `string.required(message?: string | function): Schema`\n\nThe same as the `mixed()` schema required, except that empty strings are also considered 'missing' values.\n\n#### `string.length(limit: number | Ref, message?: string | function): Schema`\n\nSet a required length for the string value. The `${length}` interpolation can be used in the `message` argument\n\n#### `string.min(limit: number | Ref, message?: string | function): Schema`\n\nSet a minimum length limit for the string value. The `${min}` interpolation can be used in the `message` argument\n\n#### `string.max(limit: number | Ref, message?: string | function): Schema`\n\nSet a maximum length limit for the string value. The `${max}` interpolation can be used in the `message` argument\n\n#### `string.matches(regex: Regex, message?: string | function): Schema`\n\nProvide an arbitrary `regex` to match the value against.\n\n```js\nlet schema = string().matches(/(hi|bye)/);\n\nawait schema.isValid('hi'); // => true\nawait schema.isValid('nope'); // => false\n```\n\n#### `string.matches(regex: Regex, options: { message: string, excludeEmptyString: bool }): Schema`\n\nAn alternate signature for `string.matches` with an options object. `excludeEmptyString`, when true,\nshort circuits the regex test when the value is an empty string\n\n```js\nlet schema = string().matches(/(hi|bye)/, { excludeEmptyString: true });\n\nawait schema.isValid(''); // => true\n```\n\n#### `string.email(message?: string | function): Schema`\n\nValidates the value as an email address via a regex.\n\n#### `string.url(message?: string | function): Schema`\n\nValidates the value as a valid URL via a regex.\n\n#### `string.ensure(): Schema`\n\nTransforms `undefined` and `null` values to an empty string along with\nsetting the `default` to an empty string.\n\n#### `string.trim(message?: string | function): Schema`\n\nTransforms string values by removing leading and trailing whitespace. If\n`strict()` is set it will only validate that the value is trimmed.\n\n#### `string.lowercase(message?: string | function): Schema`\n\nTransforms the string value to lowercase. If `strict()` is set it\nwill only validate that the value is lowercase.\n\n#### `string.uppercase(message?: string | function): Schema`\n\nTransforms the string value to uppercase. If `strict()` is set it\nwill only validate that the value is uppercase.\n\n### number\n\nDefine a number schema. Supports all the same methods as [`mixed`](#mixed).\n\n```js\nlet schema = yup.number();\n\nawait schema.isValid(10); // => true\n```\n\nThe default `cast` logic of `number` is: [`parseFloat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat).\n\nFailed casts return `NaN`.\n\n#### `number.min(limit: number | Ref, message?: string | function): Schema`\n\nSet the minimum value allowed. The `${min}` interpolation can be used in the\n`message` argument.\n\n#### `number.max(limit: number | Ref, message?: string | function): Schema`\n\nSet the maximum value allowed. The `${max}` interpolation can be used in the\n`message` argument.\n\n#### `number.lessThan(max: number | Ref, message?: string | function): Schema`\n\nValue must be less than `max`. The `${less}` interpolation can be used in the\n`message` argument.\n\n#### `number.moreThan(min: number | Ref, message?: string | function): Schema`\n\nValue must be strictly greater than `min`. The `${more}` interpolation can be used in the\n`message` argument.\n\n#### `number.positive(message?: string | function): Schema`\n\nValue must be a positive number.\n\n#### `number.negative(message?: string | function): Schema`\n\nValue must be a negative number.\n\n#### `number.integer(message?: string | function): Schema`\n\nValidates that a number is an integer.\n\n#### `number.truncate(): Schema`\n\nTransformation that coerces the value to an integer by stripping off the digits\nto the right of the decimal point.\n\n#### `number.round(type: 'floor' | 'ceil' | 'trunc' | 'round' = 'round'): Schema`\n\nAdjusts the value via the specified method of `Math` (defaults to 'round').\n\n### boolean\n\nDefine a boolean schema. Supports all the same methods as [`mixed`](#mixed).\n\n```js\nlet schema = yup.boolean();\n\nawait schema.isValid(true); // => true\n```\n\n### date\n\nDefine a Date schema. By default ISO date strings will parse correctly,\nfor more robust parsing options see the extending schema types at the end of the readme.\nSupports all the same methods as [`mixed`](#mixed).\n\n```js\nlet schema = yup.date();\n\nawait schema.isValid(new Date()); // => true\n```\n\nThe default `cast` logic of `date` is pass the value to the `Date` constructor, failing that, it will attempt\nto parse the date as an ISO date string.\n\nFailed casts return an invalid Date.\n\n#### `date.min(limit: Date | string | Ref, message?: string | function): Schema`\n\nSet the minimum date allowed. When a string is provided it will attempt to cast to a date first\nand use the result as the limit.\n\n#### `date.max(limit: Date | string | Ref, message?: string | function): Schema`\n\nSet the maximum date allowed, When a string is provided it will attempt to cast to a date first\nand use the result as the limit.\n\n### array\n\nDefine an array schema. Arrays can be typed or not, When specifying the element type, `cast` and `isValid`\nwill apply to the elements as well. Options passed into `isValid` are passed also passed to child schemas.\nSupports all the same methods as [`mixed`](#mixed).\n\n```js\nlet schema = yup.array().of(yup.number().min(2));\n\nawait schema.isValid([2, 3]); // => true\nawait schema.isValid([1, -24]); // => false\n\nschema.cast(['2', '3']); // => [2, 3]\n```\n\nYou can also pass a subtype schema to the array constructor as a convenience.\n\n```js\narray().of(yup.number());\n// or\narray(yup.number());\n```\n\nThe default `cast` behavior for `array` is: [`JSON.parse`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)\n\nFailed casts return: `null`;\n\n#### `array.of(type: Schema): Schema`\n\nSpecify the schema of array elements. `of()` is optional and when omitted the array schema will\nnot validate its contents.\n\n#### `array.required(message?: string | function): Schema`\n\nThe same as the `mixed()` schema required, except that empty arrays are also considered 'missing' values.\n\n#### `array.min(limit: number | Ref, message?: string | function): Schema`\n\nSet a minimum length limit for the array. The `${min}` interpolation can be used in the `message` argument.\n\n#### `array.max(limit: number | Ref, message?: string | function): Schema`\n\nSet a maximum length limit for the array. The `${max}` interpolation can be used in the `message` argument.\n\n#### `array.ensure(): Schema`\n\nEnsures that the value is an array, by setting the default to `[]` and transforming `null` and `undefined`\nvalues to an empty array as well. Any non-empty, non-array value will be wrapped in an array.\n\n```js\narray()\n  .ensure()\n  .cast(null); // => []\narray()\n  .ensure()\n  .cast(1); // => [1]\narray()\n  .ensure()\n  .cast([1]); // => [1]\n```\n\n#### `array.compact(rejector: (value) => boolean): Schema`\n\nRemoves falsey values from the array. Providing a rejecter function lets you specify the rejection criteria yourself.\n\n```js\narray()\n  .compact()\n  .cast(['', 1, 0, 4, false, null]); // => [1, 4]\n\narray()\n  .compact(function(v) {\n    return v == null;\n  })\n  .cast(['', 1, 0, 4, false, null]); // => ['', 1, 0, 4, false]\n```\n\n### object\n\nDefine an object schema. Options passed into `isValid` are also passed to child schemas.\nSupports all the same methods as [`mixed`](#mixed).\n\n```js\nyup.object().shape({\n  name: string().required(),\n  age: number()\n    .required()\n    .positive()\n    .integer(),\n  email: string().email(),\n  website: string().url(),\n});\n```\n\nYou can also pass a shape to the object constructor as a convenience.\n\n```js\nobject().shape({\n  num: number(),\n});\n// or\nobject({\n  num: number(),\n});\n```\n\nThe default `cast` behavior for `object` is: [`JSON.parse`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)\n\nFailed casts return: `null`;\n\n#### `object.shape(fields: object, noSortEdges?: Array<[string, string]>): Schema`\n\nDefine the keys of the object and the schemas for said keys.\n\nNote that you can chain `shape` method, which acts like object extends, for example:\n\n```js\nobject({\n  a: string(),\n  b: number(),\n}).shape({\n  b: string(),\n  c: number(),\n});\n```\n\nwould be exactly the same as:\n\n```js\nobject({\n  a: string(),\n  b: string(),\n  c: number(),\n});\n```\n\n#### `object.from(fromKey: string, toKey: string, alias: boolean = false): Schema`\n\nTransforms the specified key to a new key. If `alias` is `true` then the old key will be left.\n\n```js\nlet schema = object({\n  myProp: mixed(),\n  Other: mixed(),\n})\n  .from('prop', 'myProp')\n  .from('other', 'Other', true);\n\nschema.cast({ prop: 5, other: 6 }); // => { myProp: 5, other: 6, Other: 6 }\n```\n\n#### `object.noUnknown(onlyKnownKeys: boolean = true, message?: string | function): Schema`\n\nValidate that the object value only contains keys specified in `shape`, pass `false` as the first\nargument to disable the check. Restricting keys to known, also enables `stripUnknown` option, when not in strict mode.\n\n#### `object.camelCase(): Schema`\n\nTransforms all object keys to camelCase\n\n#### `object.constantCase(): Schema`\n\nTransforms all object keys to CONSTANT_CASE.\n\n## Extending Schema Types\n\nThe simplest way to extend an existing type is just to cache a configured schema and use that through your application.\n\n```js\nlet yup = require('yup');\nlet parseFormats = ['MMM dd, yyy'];\nlet invalidDate = new Date('');\n\nmodule.exports = yup.date().transform(function(value, originalValue) {\n  if (this.isType(value)) return value;\n  // the default coercion transform failed so lets try it with Moment instead\n  value = Moment(originalValue, parseFormats);\n  return value.isValid() ? value.toDate() : invalidDate;\n});\n```\n\nAlternatively, each schema is a normal JavaScript constructor function that you can mutate or delegate to\nusing the normal patterns. Generally you should not inherit from `mixed` unless you know what you are doing,\nbetter to think of it as an abstract class. The other types are fair game though.\n\nYou should keep in mind some basic guidelines when extending schemas\n\n- never mutate an existing schema, always `clone()` and then mutate the new one before returning it.\n  Built-in methods like `test` and `transform` take care of this for you, so you can safely use them (see below) without worrying\n- transforms should never mutate the `value` passed in, and should return an invalid object when one exists\n  (`NaN`, `InvalidDate`, etc) instead of `null` for bad values.\n- by the time validations run the `value` is guaranteed to be the correct type, however if `nullable` is\n  set then `null` is a valid value for that type, so don't assume that a property or method exists on the value.\n\n**Adjust core Types**\n\n```js\nlet invalidDate = new Date('');\n\nfunction parseDateFromFormats(formats, parseStrict) {\n  return this.transform(function(value, originalValue) {\n    if (this.isType(value)) return value;\n\n    value = Moment(originalValue, formats, parseStrict);\n\n    return value.isValid() ? value.toDate() : invalidDate;\n  });\n}\n\n// `addMethod` doesn't do anything special it's\n// equivalent to: yup.date.prototype.format = parseDateFromFormats\nyup.addMethod(yup.date, 'format', parseDateFromFormats);\n```\n\n**Creating new Types**\n\nYup schema use the common constructor pattern for modeling inheritance. You can use any\nutility or pattern that works with that pattern. The below demonstrates using the es6 class\nsyntax since its less verbose, but you absolutely aren't required to use it.\n\n```js\nlet DateSchema = yup.date;\nlet invalidDate = new Date(''); // our failed to coerce value\n\nclass MomentDateSchemaType extends DateSchema {\n  constructor() {\n    super();\n    this._validFormats = [];\n\n    this.withMutation(() => {\n      this.transform(function(value, originalvalue) {\n        if (this.isType(value))\n          // we have a valid value\n          return value;\n        return Moment(originalValue, this._validFormats, true);\n      });\n    });\n  }\n\n  _typeCheck(value) {\n    return (\n      super._typeCheck(value) || (moment.isMoment(value) && value.isValid())\n    );\n  }\n\n  format(formats) {\n    if (!formats) throw new Error('must enter a valid format');\n    let next = this.clone();\n    next._validFormats = {}.concat(formats);\n  }\n}\n\nlet schema = new MomentDateSchemaType();\n\nschema.format('YYYY-MM-DD').cast('It is 2012-05-25'); // => Fri May 25 2012 00:00:00 GMT-0400 (Eastern Daylight Time)\n```\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2014 Jason Quense\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/yup/-/yup-0.27.0.tgz#f8cb198c8e7dd2124beddc2457571329096b06e7",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/yup/-/yup-0.27.0.tgz",
    "hash": "f8cb198c8e7dd2124beddc2457571329096b06e7",
    "integrity": "sha512-v1yFnE4+u9za42gG/b/081E7uNW9mUj3qtkmelLbW5YPROZzSH/KUUyJu9Wt8vxFJcT9otL/eZopS0YK1L5yPQ==",
    "registry": "npm",
    "packageName": "yup",
    "cacheIntegrity": "sha512-v1yFnE4+u9za42gG/b/081E7uNW9mUj3qtkmelLbW5YPROZzSH/KUUyJu9Wt8vxFJcT9otL/eZopS0YK1L5yPQ== sha1-+MsZjI590hJL7dwkV1cTKQlrBuc="
  },
  "registry": "npm",
  "hash": "f8cb198c8e7dd2124beddc2457571329096b06e7"
}