{
  "manifest": {
    "name": "devcert",
    "version": "1.1.2",
    "description": "Generate trusted local SSL/TLS certificates for local SSL development",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": {
      "build": "tsc",
      "prepublishOnly": "npm run build",
      "test": "echo \"Ha.\" && exit 1"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/davewasmer/devcert.git"
    },
    "keywords": [
      "ssl",
      "certificate",
      "openssl",
      "trust"
    ],
    "author": {
      "name": "Dave Wasmer"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/davewasmer/devcert/issues"
    },
    "homepage": "https://github.com/davewasmer/devcert#readme",
    "devDependencies": {
      "standard-version": "^4.3.0",
      "typescript": "^2.9.2"
    },
    "dependencies": {
      "@types/configstore": "^2.1.1",
      "@types/debug": "^0.0.30",
      "@types/get-port": "^3.2.0",
      "@types/glob": "^5.0.34",
      "@types/lodash": "^4.14.92",
      "@types/mkdirp": "^0.5.2",
      "@types/node": "^8.5.7",
      "@types/rimraf": "^2.0.2",
      "@types/tmp": "^0.0.33",
      "application-config-path": "^0.1.0",
      "command-exists": "^1.2.4",
      "configstore": "^3.0.0",
      "debug": "^3.1.0",
      "eol": "^0.9.1",
      "get-port": "^3.2.0",
      "glob": "^7.1.2",
      "lodash": "^4.17.4",
      "mkdirp": "^0.5.1",
      "password-prompt": "^1.0.4",
      "rimraf": "^2.6.2",
      "sudo-prompt": "^8.2.0",
      "tmp": "^0.0.33",
      "tslib": "^1.10.0"
    },
    "optionalDependencies": {},
    "_registry": "npm",
    "_loc": "/home/senmioxl/.cache/yarn/v6/npm-devcert-1.1.2-5c4f816e27be540c68916e0f023cf8774f2616d6-integrity/node_modules/devcert/package.json",
    "readmeFilename": "README.md",
    "readme": "# devcert - Development SSL made easy\n\nSo, running a local HTTPS server usually sucks. There's a range of\napproaches, each with their own tradeoff. The common one, using self-signed\ncertificates, means having to ignore scary browser warnings for each project.\n\ndevcert makes the process easy. Want a private key and certificate file to\nuse with your server? Just ask:\n\n```js\nlet ssl = await devcert.certificateFor('my-app.test');\nhttps.createServer(ssl, app).listen(3000);\n```\n\nNow open https://my-app.test:3000 and voila - your page loads with no scary\nwarnings or hoops to jump through.\n\n> Certificates are cached by name, so two calls for\n`certificateFor('foo')` will return the same key and certificate.\n\n## Options\n\nWhen it installs or upgrades, devcert creates a self-signed certificate\nauthority (CA) which it uses to sign all certificates it creates. It will try\nto register this CA with OS keychains in OSX, Linux, and Windows. However,\nsome HTTP clients (such as Firefox and NodeJS itself) use their own trusted\ncertificate list instead of the operating system's keychain. The `getCaPath`\nand `getCaBuffer` options make the CA available in the `certificateFor()`\nreturn object itself, so that these programs can choose whether to trust it.\n\n### getCaPath\n\nSet this option to `true` and the returned object will inlude a `caPath`\nproperty, set to the file path of the certificate authority file. Use this\npath to add the certificate to local trust stores which accept paths as\narguments, such as NodeJS's builtin environment variable\n`NODE_EXTRA_CA_CERTS`..\n\n### getCaBuffer\n\nSet this option to `true` and the returned object will inlude a `ca`\nproperty, set to the UTF-8-encoded contents of the certificate authority\nfile. Use this path to add the certificate to local trust stores which don't\nuse OS settings, lke the examples mentioned above.\n\n### skipHostsFile\n\nIf you supply a custom domain name (i.e. any domain other than `localhost`)\nwhen requesting a certificate from devcert, it will attempt to modify your\nsystem to redirect requests for that domain to your local machine (rather\nthan to the real domain). It does this by modifying your `/etc/hosts` file.\n\nIf you pass in the `skipHostsFile` option, devcert will skip this step. This\nmeans that if you ask for certificates for `my-app.test` (for example), and\ndon't have some other DNS redirect method in place, that you won't be able to\naccess your app at `https://my-app.test` because your computer wouldn't know\nthat `my-app.test` should resolve your local machine.\n\nKeep in mind that SSL certificates are issued for _domains_, so if you ask\nfor a certificate for `my-app.test`, and don't have any kind of DNS redirect\nin place (`/etc/hosts` or otherwise), trying to hit `localhost` won't work,\neven if the app you intended to serve via `my-app.test` is running on your\nlocal machine (since the SSL certificate won't say `localhost`).\n\n### skipCertutil\n\nThis option will tell devcert to avoid installing `certutil` tooling.\n\n`certutil` is a tooling package used to automated the installation of SSL\ncertificates in certain circumstances; specifically, Firefox (for every OS)\nand Chrome (on Linux only).\n\nNormally, devcert will attempt to install `certutil` if it's need and not\nalready present on your system. If don't want devcert to install this\npackage, pass `skipCertutil: true`.\n\nIf you decide to `skipCertutil`, the initial setup process for devcert\nchanges in these two scenarios:\n\n* **Firefox on all platforms**: Thankully, Firefox makes this easy. There's a\n  point-and-click wizard for importing and trusting a certificate, so if you\n  specify `skipCertutil: true`, devcert will instead automatically open Firefox\n  and kick off this wizard for you. Simply follow the prompts to trust the\n  certificate. **Reminder: you'll only need to do this once per machine**\n\n* **Chrome on Linux**: Unfortunately, it appears that the **only** way to get\n  Chrome to trust an SSL certificate on Linux is via the `certutil` tooling -\n  there is no manual process for it. Thus, if you are using Chrome on Linux, do\n  **not** supply `skipCertuil: true`. If you do, devcert certificates will not\n  be trusted by Chrome.\n\nThe `certutil` tooling is installed in OS-specific ways:\n\n* Mac: `brew install nss`\n* Linux: `apt install libnss3-tools`\n* Windows: N/A (there is no easy, hands-off way to install certutil on Windows,\n  so devcert will simply fallback to the wizard approach for Firefox outlined\n  above)\n\n## How it works\n\nWhen you ask for a development certificate, devcert will first check to see\nif it has run on this machine before. If not, it will create a root\ncertificate authority and add it to your OS and various browser trust stores.\nYou'll likely see password prompts from your OS at this point to authorize\nthe new root CA.\n\nSince your machine now trusts this root CA, it will trust any certificates\nsigned by it. So when you ask for a certificate for a new domain, devcert\nwill use the root CA credentials to generate a certificate specific to the\ndomain you requested, and returns the new certificate to you.\n\nIf you request a domain that has already had certificates generated for it,\ndevcert will simply return the cached certificates.\n\nThis setup ensures that browsers won't show scary warnings about untrusted\ncertificates, since your OS and browsers will now trust devcert's\ncertificates.\n\n## Security Concerns\n\nThere's a reason that your OS prompts you for your root password when devcert\nattempts to install it's root certificate authority. By adding it to your\nmachine's trust stores, your browsers will automatically trust _any_ certificate\ngenerated with it.\n\nThis exposes a potential attack vector on your local machine: if someone else\ncould use the devcert certificate authority to generate certificates, and if\nthey could intercept / manipulate your network traffic, they could theoretically\nimpersonate some websites, and your browser would not show any warnings (because\nit trusts the devcert authority).\n\nTo prevent this, devcert takes steps to ensure that no one can access the\ndevcert certificate authority credentials to generate malicious certificates\nwithout you knowing. The exact approach varies by platform:\n\n* **macOS and Linux**: the certificate authority's credentials are written to files that are only readable by the root user (i.e. `chown 0 ca-cert.crt` and\n`chmod 600 ca-cert.crt`). When devcert itself needs these, it shells out to\n`sudo` invocations to read / write the credentials.\n* **Windows**: because of my unfamiliarity with Windows file permissions, I\nwasn't confident I would be able to correctly set permissions to mimic the setup\non macOS and Linux. So instead, devcert will prompt you for a password, and then\nuse that to encrypt the credentials with an AES256 cipher. The password is never\nwritten to disk.\n\nTo further protect these credentials, any time they are written to disk, they\nare written to temporary files, and are immediately deleted after they are no longer needed.\n\nAdditionally, the root CA certificate is unique to your machine only: it's\ngenerated on-the-fly when it is first installed. ensuring there are no\ncentral / shared keys to crack across machines.\n\n### Why install a root certificate authority at all?\n\nThe root certificate authority makes it simpler to manage which domains are\nconfigured for SSL by devcert. The alternative is to generate and trust\nself-signed certificates for each domain. The problem is that while devcert\nis able to add a certificate to your machine's trust stores, the tooling to\nremove a certificate doesn't cover every case. So if you ever wanted to\n_untrust_ devcert's certificates, you'd have to manually remove each one from\neach trust store.\n\nBy trusting only a single root CA, devcert is able to guarantee that when you\nwant to _disable_ SSL for a domain, it can do so with no manual intervention\n- we just delete the domain-specific certificate files. Since these\ndomain-specific files aren't installed in your trust stores, once they are\ngone, they are gone.\n\n\n## Integration\n\ndevcert has been designed from day one to work as low-level library that other\ntools can delegate to. The goal is to make HTTPS development easy for everyone,\nregardless of framework or library choice.\n\nWith that in mind, if you'd like to use devcert in your library/framework/CLI,\ndevcert makes that easy.\n\nIn addition to the options above, devcert exposes a `ui` option. This option\nallows you to control all the points where devcert requries user interaction,\nsubstituting your own prompts and user interface. You can use this to brand\nthe experience with your own tool's name, localize the messages, or integrate\ndevcert into a larger existing workflow.\n\nThe `ui` option should be an object with the following methods:\n\n```ts\n{\n  async getWindowsEncryptionPassword(): Promise<string> {\n    // Invoked when devcert needs the password used to encrypt the root\n    // certificate authority credentials on Windows. May be invoked multiple\n    // times if the user's supplied password is incorrect\n  },\n  async warnChromeOnLinuxWithoutCertutil(): Promise<string> {\n    // Invoked when devcert is run on Linux, detects that Chrome is installed,\n    // and the `skipCertutil` option is `true`. Used to warn the user that\n    // Chrome will not work with `skipCertutil: true` on Linux.\n  },\n  async closeFirefoxBeforeContinuing() {\n    // Invoked when devcert detects that Firefox is running while it is trying\n    // to programmatically install it's certificate authority in the Firefox\n    // trust store. Firefox appears to overwrite changes to the trust store on\n    // exit, so Firefox must be closed before devcert can continue. devcert will\n    // wait for Firefox to exit - this is just to prompt the user that they\n    // need to close the application.\n  },\n  async startFirefoxWizard(certificateHost: string) {\n    // Invoked when devcert detects a Firefox installation and `skipCertutil:\n    // true` was specified. This is invoked right before devcert launches the\n    // Firefox certificate import wizard GUI. Used to give the user a heads up\n    // as to why they are about to see Firefox pop up.\n    //\n    // The certificateHost provided is the URL for the temporary server that\n    // devcert has spun up in order to trigger the wizard(Firefox needs try to\n    // \"download\" the cert to trigger the wizard). This URL will load the page\n    // supplied in the `firefoxWizardPromptPage()` method below.\n    //\n    // Normally, devcert will automatically open this URL, but in case it fails\n    // you may want to print it out to the console with an explanatory message\n    // so the user isn't left hanging wondering what's happening.\n  },\n  async firefoxWizardPromptPage(certificateURL: string): Promise<string> {\n    // When devcert starts the Firefox certificate installation wizard GUI, it\n    // first loads an HTML page in Firefox. The template used for that page is\n    // the return value of this method. The supplied certificateURL is the path\n    // to the actual certificate. The Firefox tab must attempt to load this URL\n    // to trigger the wizard.\n    //\n    // The default implemenation is a simple redirect to that URL. But you could\n    // supply your own branded template here, with a button that says \"Install\n    // certificate\" that is linked to the certificateURL, along with a more in\n    // depth explanation of what is happening for example.\n  }\n  async waitForFirefoxWizard() {\n    // Invoked _after_ the Firefox certificate import wizard is kicked off. This\n    // method should not resolve until the user indicates that the wizard is\n    // complete (unfortunately, we have no way of determining that\n    // programmatically)\n  }\n}\n```\n\nYou can supply any or all of these methods - ones you do not supply will fall\nback to the default implemenation.\n\n## Testing\n\nTesting a tool like devcert can be a pain. I haven't found a good automated\nsolution for cross platform GUI testing (the GUI part is necessary to test\neach browser's handling of devcert certificates, as well as test the Firefox\nwizard flow).\n\nTo make things easier, devcert comes with a series of virtual machine images. Each one is a snapshot taken right before running a test - just launch the machine and hit <Enter>.\n\nYou can also use the snapshotted state of the VMs to roll them back to a\npristine state for another round of testing.\n\n> **Note**: Be aware that the macOS license terms prohibit running it on\n> non-Apple hardware, so you must own a Mac to test that platform. If you don't\n> own a Mac - that's okay, just mention in the PR that you were unable to test\n> on a Mac and we're happy to test it for you.\n\n### Virtual Machine Snapshots\n\n* [macOS](https://s3-us-west-1.amazonaws.com/devcert-test-snapshots/macOS.pvm.zip)\n* [Windows](https://s3-us-west-1.amazonaws.com/devcert-test-snapshots/MSEdge+-+Win10.zip)\n* [Ubuntu](https://s3-us-west-1.amazonaws.com/devcert-test-snapshots/Ubuntu+Linux.zip)\n\n## License\n\nMIT © [Dave Wasmer](http://davewasmer.com)\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/devcert/-/devcert-1.1.2.tgz#5c4f816e27be540c68916e0f023cf8774f2616d6",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/devcert/-/devcert-1.1.2.tgz",
    "hash": "5c4f816e27be540c68916e0f023cf8774f2616d6",
    "integrity": "sha512-B72N5Z2Lzu11dsPvg/KD9IwQCyNg6JgsNcHw7zJ+QQN9/rusMpc0tSSOYLczmty5D7vOs94IHITPQ0uei5D3cw==",
    "registry": "npm",
    "packageName": "devcert",
    "cacheIntegrity": "sha512-B72N5Z2Lzu11dsPvg/KD9IwQCyNg6JgsNcHw7zJ+QQN9/rusMpc0tSSOYLczmty5D7vOs94IHITPQ0uei5D3cw== sha1-XE+Bbie+VAxokW4PAjz4d08mFtY="
  },
  "registry": "npm",
  "hash": "5c4f816e27be540c68916e0f023cf8774f2616d6"
}