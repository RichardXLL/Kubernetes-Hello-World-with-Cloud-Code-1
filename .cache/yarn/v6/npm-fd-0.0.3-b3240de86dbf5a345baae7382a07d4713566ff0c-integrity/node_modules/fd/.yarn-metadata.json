{
  "manifest": {
    "name": "fd",
    "description": "File descriptor manager",
    "version": "0.0.3",
    "homepage": "https://github.com/rvagg/node-fd",
    "authors": [
      "Rod Vagg <rod@vagg.org> (https://github.com/rvagg)"
    ],
    "keywords": [
      "fd",
      "fs",
      "descriptor",
      "file"
    ],
    "main": "./index.js",
    "repository": {
      "type": "git",
      "url": "https://github.com/rvagg/node-fd.git"
    },
    "dependencies": {},
    "devDependencies": {
      "tap": "*",
      "sinon": "*",
      "mkfiletree": "*"
    },
    "scripts": {
      "test": "tap test.js"
    },
    "license": "MIT",
    "_registry": "npm",
    "_loc": "/home/senmioxl/.cache/yarn/v6/npm-fd-0.0.3-b3240de86dbf5a345baae7382a07d4713566ff0c-integrity/node_modules/fd/package.json",
    "readmeFilename": "README.md",
    "readme": "# fd [![Build Status](https://secure.travis-ci.org/rvagg/node-fd.png)](http://travis-ci.org/rvagg/node-fd)\n\nFile descriptor manager for Node.js. *Available in npm as <strong>fd</strong>*.\n\n**fd** manages `fs.open()` and `fs.close()` calls safely for you where there may be timing issues related to multiple-use of the same descriptor.\n\n**fd** provides `checkin()` and `checkout()` functions so your application can register its intent to use a file descriptor after it's been opened and then register that it has finished with the descriptor so that any pending `fs.close()` operations may be performed.\n\n**fd** naturally couples with [async-cache](https://github.com/isaacs/async-cache) to provide a safe pool of file descriptors.\n\n## Example\n\nLets make a static resource web server! This example can be found in the *example/* directory of this repository.\n\nWe use [async-cache](https://github.com/isaacs/async-cache) to cache both `fs.sync()` calls and `fd`s, but we hook it up to **fd** so we can safely manage opens and closes.\n\n```js\nconst fdman = require('fd')()\n    , http  = require('http')\n    , fs    = require('fs')\n    , path  = require('path')\n    , AC    = require('async-cache')\n    , mime  = require('mime')\n\n    , ROOT  = path.join(__dirname, 'public')\n\n      // an async cache for fs.stat calls, fresh for 10s\n    , statCache = AC({\n          max    : 100\n        , maxAge : 10000\n        , load   : function (path, callback) {\n                     fs.stat(path, callback)\n                   }\n      })\n\n      // an async cache for fds, fresh for 10s\n    , fdCache = AC({\n          max     : 100\n        , maxAge  : 10000\n          // use fdman to open & close\n        , load    : fdman.open.bind(fdman)\n        , dispose : fdman.close.bind(fdman)\n      })\n\n    , serveError = function (res) {\n        res.statusCode = 404\n        res.setHeader('content-type', 'text/plain')\n        res.end(http.STATUS_CODES[res.statusCode] + '\\n')\n      }\n\nhttp.createServer(function (req, res) {\n  var p = path.join(ROOT, req.url)\n\n  // get a fs.stat for this file\n  statCache.get(p, function (err, stat) {\n    if (err || !stat.isFile())\n      return serveError(res)\n\n    // get an fd for this file\n    fdCache.get(p, function (err, fd) {\n      var mimeType = mime.lookup(path.extname(p))\n          // get a safe checkin function from fdman that\n          // we could safely all multiple times for this single\n          // checkout\n        , checkin = fdman.checkinfn(p, fd)\n\n      // check out the fd for use\n      fdman.checkout(p, fd)\n\n      res.setHeader(\n          'content-type'\n          // don't force download, just show it\n        , mimeType != 'application/octet-stream' ? mimeType : 'text/plain'\n      )\n\n      // stream from the fd to the response\n      var st = fs.createReadStream(p, { fd: fd, start: 0, end: stat.size })n\n        .on('end', checkin)\n        .on('error', checkin)\n\n      // override destroy so we don't close the fd\n      st.destroy = function () {}\n\n      st.pipe(res)\n\n    })\n  })\n}).listen(8080)\n```\n\n## API\n\n### fd()\nCreate a new instance of **fd**. Typically called with `var fdman = require('fd')()`. You can have multiple, separate instances of **fd** operating at the same time, hence the need to instantiate.\n\n### fdman.open(path, callback)\nEquivalent to `fs.open(path, callback)`, you'll get back an `err` and `fd` parameters but the descriptor will go into the managed pool.\n\n### fdman.close(path, fd)\nWill call `fs.close(fd)` *only when the `fd` is no longer in use*. i.e. it will wait till all current uses have been checked in (see below).\n\n### fdman.checkout(path, fd)\nCalled when your application may need to use the `fd`. This should be called as early as possible, even if your application may not end up using it.\n\nIt is important to perform a `checkout()` as soon as you have a reference to the file descriptor if you may be using it, otherwise an asynchronous call may interrupt and call `close()` before you use it. You *don't have to use the `fd`* to register your intent to use it, as long as you eventually call `checkin()`.\n\n### fdman.checkin(path, fd)\nRegister with **fd** that you have finished using the descriptor and it can be safely closed if need be.\n\nThe descriptor may not need to be closed or there may be other uses of the descriptor currently checked out so a `checkin()` won't automatically lead to a `close()`.\n\n### fdman.checkinfn(path, fd)\nReturns a function that, when called, will safely perform a `checkin()` for you on the given path and descriptor. An important property of the function is that it will only perform a single `checkin()` regardless of how many times it is called.\n\nThis returned function is helpful for calling `checkin()` from multiple points in your application, such as in case of error, and you don't need to worry about whether it's been previously called for the current `checkout()`.\n\nSee the example above how this can be used.\n\n\n## Licence\n\nfd is Copyright (c) 2012 Rod Vagg [@rvagg](https://twitter.com/rvagg) and licenced under the MIT licence. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.",
    "licenseText": "Copyright 2012, Rod Vagg (the \"Original Author\")\nAll rights reserved.\n\nMIT +no-false-attribs License\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nDistributions of all or part of the Software intended to be used\nby the recipients as they would use the unmodified Software,\ncontaining modifications that substantially alter, remove, or\ndisable functionality of the Software, outside of the documented\nconfiguration mechanisms provided by the Software, shall be\nmodified such that the Original Author's bug reporting email\naddresses and urls are either replaced with the contact information\nof the parties responsible for the changes, or removed entirely.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\n\nExcept where noted, this license applies to any and all software\nprograms and associated documentation files created by the\nOriginal Author, when distributed with the Software."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/fd/-/fd-0.0.3.tgz#b3240de86dbf5a345baae7382a07d4713566ff0c",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/fd/-/fd-0.0.3.tgz",
    "hash": "b3240de86dbf5a345baae7382a07d4713566ff0c",
    "integrity": "sha512-iAHrIslQb3U68OcMSP0kkNWabp7sSN6d2TBSb2JO3gcLJVDd4owr/hKM4SFJovFOUeeXeItjYgouEDTMWiVAnA==",
    "registry": "npm",
    "packageName": "fd",
    "cacheIntegrity": "sha512-iAHrIslQb3U68OcMSP0kkNWabp7sSN6d2TBSb2JO3gcLJVDd4owr/hKM4SFJovFOUeeXeItjYgouEDTMWiVAnA== sha1-syQN6G2/WjRbquc4KgfUcTVm/ww="
  },
  "registry": "npm",
  "hash": "b3240de86dbf5a345baae7382a07d4713566ff0c"
}