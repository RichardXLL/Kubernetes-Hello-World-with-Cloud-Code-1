{
  "manifest": {
    "name": "@reach/descendants",
    "version": "0.10.5",
    "description": "A descendant index solution for better accessibility support in compound components",
    "author": {
      "name": "React Training",
      "email": "hello@reacttraining.com"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/reach/reach-ui.git",
      "directory": "packages/descendants"
    },
    "scripts": {
      "build": "ts-node ../../scripts/build"
    },
    "dependencies": {
      "@reach/utils": "0.10.5",
      "tslib": "^2.0.0"
    },
    "peerDependencies": {
      "react": "^16.8.0",
      "react-dom": "^16.8.0"
    },
    "main": "dist/index.js",
    "module": "dist/descendants.esm.js",
    "typings": "dist/index.d.ts",
    "files": [
      "README.md",
      "dist"
    ],
    "gitHead": "86a046f54d53b6420e392b3fa56dd991d9d4e458",
    "_registry": "npm",
    "_loc": "/home/senmioxl/.cache/yarn/v6/npm-@reach-descendants-0.10.5-2611174e9e9b326dba548356221e2f8c8f5c8612-integrity/node_modules/@reach/descendants/package.json",
    "readmeFilename": "README.md",
    "readme": "# @reach/descendants\n\n[![Stable release](https://img.shields.io/npm/v/@reach/descendants.svg)](https://npm.im/@reach/descendants) ![MIT license](https://badgen.now.sh/badge/license/MIT)\n\nA descendant index solution for better accessibility support in compound components.\n\n**Important:** This package is primarily intended for internal use by the Reach UI library. You should probably not use it directly in your production projects, as the APIs can still change with minor version bumps (at least until we're comfortable releasing a 1.0). You have been warned!\n\n## The Problem\n\nIn React you can wrap up any elements into a component and then render the new component instead. It's beautiful.\n\n```jsx\n// old\n<h1>Time zones</h1>\n<select>\n  <option>Eastern</option>\n  <option>Central</option>\n  <option>Mountain</option>\n  <option>Pacific</option>\n  <option>UTC-10</option>\n  <option>UTC-09</option>\n  <option>UTC-09:30</option>\n  {/* etc. */}\n</select>\n\n// new\n<h1>Time zones</h1>\n<select>\n  <LocaleTimeZoneOptions/>\n  <UTCTimeZoneOptions/>\n</select>\n\nfunction LocaleTimeZoneOptions() {\n  return (\n    <>\n      <option>Eastern</option>\n      <option>Central</option>\n      <option>Mountain</option>\n      <option>Pacific</option>\n    </>\n  )\n}\n```\n\nEverything will continue to work!\n\nBut when we want to create our own abstractions like this, we can't always abstract and compose the same way.\n\nThe Menu here will set an `aria-activedescendant={activeElementId}` so that assistive tech can announce correctly. The menu also needs a ref to the children so it can set them as the active descendant (or actually focus the node) from keyboard events like `ArrowUp` and `ArrowDown`.\n\nAdditionally, `MenuItem` needs to know if it is the active descendant so it can style itself differently.\n\n```jsx\n<Menu>\n  <MenuItem onSelect={download}>Download</MenuItem>\n  <MenuItem onSelect={save}>Save</MenuItem>\n  <MenuItem onSelect={preview}>Preview</MenuItem>\n</Menu>\n```\n\nThere are a few ways to deal with this.\n\n## Option 1: Bail out of Elements\n\nThe solution most people turn to is to bail out of the element API and turn to arrays. This lets a single owner control the state and rendering, makes it way easier to know the index and set the active descendant.\n\n```jsx\n<Menu\n  items={[\n    { label: \"Download\", onSelect: download },\n    { label: \"Save\", onSelect: save },\n    { label: \"Preview\", onSelect: preview },\n  ]}\n/>;\n\nfunction Menu({ items }) {\n  const [activeIndex, setActiveIndex] = useState();\n  return (\n    <div data-menu aria-activedescendant={activeIndex}>\n      {items.map((item, index) => (\n        <MenuItem\n          // easy to tell the index\n          index={index}\n          activeIndex={activeIndex}\n          onSelect={item.onSelect}\n        >\n          {item.label}\n        </MenuItem>\n      ))}\n    </div>\n  );\n}\n\nfunction MenuItem({ index, activeIndex, onSelect, children }) {\n  // and now we can style\n  const isActive = index === activeIndex;\n  return (\n    <div\n      // and add an ID\n      id={index}\n      data-highlighted={isActive ? \"\" : undefined}\n    >\n      {children}\n    </div>\n  );\n}\n```\n\nThis is where most people live. You see these APIs everywhere because it's way easier when you own all the state and all the elements in one place. But you lose composition.\n\nWhat happens when we want to add a className to all, one, or just a few of the elements? You end up with weird APIs like:\n\n```jsx\n<Menu\n  options={[\n    { label: \"Download\", onSelect: download },\n    { label: \"Save\", onSelect: save },\n    { label: \"Preview\", onSelect: preview },\n  ]}\n  // stuff like this\n  optionClassNames=\"cool\"\n  // or shoot, we need more than classNames\n  optionsProps={{\n    className: \"cool\",\n    onMouseEnter: handler,\n  }}\n  // dangit we need to do it differently depending on the option\n  getOptionProps={(option, index) => {\n    return index === 2 ? \"bg-blue\" : \"bg-white\";\n  }}\n  // ah forget it, here you do it, enjoy the branching!\n  renderOption={(option, index) => (\n    <MenuItem\n      className={index === 2 ? \"bg-blue\" : \"bg-white\"}\n      aria-label={index === 2 ? \"Preview Invoice\" : undefined}\n    >\n      {index === 0 ? (\n        <DownloadIcon />\n      ) : index === 1 ? (\n        <SaveIcon />\n      ) : index === 2 ? (\n        <PreviewIcon />\n      ) : null}\n      {option.label}\n    </MenuItem>\n  )}\n/>\n```\n\nBecause the rendering is in the same owner as the state, we have to poke holes in the component to change anything about how it renders.\n\nAll that, just so the stinking `MenuOption` knows its index in the parent's element tree.\n\nHad we stuck to elements, we could have done this:\n\n```jsx\n<Menu>\n  <MenuItem className=\"bg-white\" onSelect={download}>\n    <DownloadIcon /> Download\n  </MenuItem>\n  <MenuItem className=\"bg-white\" onSelect={save}>\n    <SaveIcon /> Save\n  </MenuItem>\n  <MenuItem\n    className=\"bg-white\"\n    onSelect={preview}\n    aria-label=\"Preview Invoice\"\n  >\n    <PreviewIcon /> Preview\n  </MenuItem>\n</Menu>\n```\n\nBut how will the `MenuItem` components know their index?\n\n## Option 2: Type Checking and `cloneElement`\n\nWe can use `React.cloneElement` to keep (most of) the normal React composition. No more `items` prop. Instead we map the children, clone them, and pass them the state that we know in Menu.\n\n```jsx\nfunction Menu({ children }) {\n  const [activeIndex, setActiveIndex] = useState();\n  return (\n    <div data-menu aria-activedescendant={activeIndex}>\n      {React.Children.map(children, (child, index) =>\n        React.cloneElement(child, { index, activeIndex })\n      )}\n    </div>\n  );\n}\n\nfunction MenuItem({ index, activeIndex, onSelect, children }) {\n  // index came from the clone\n  const isActive = index === activeIndex;\n  return (\n    <div id={index} data-highlighted={isActive ? \"\" : undefined}>\n      {children}\n    </div>\n  );\n}\n```\n\nWe've now seperated the state from the elements so that apps can compose however they please. If you want to put a `className` on one item and not another, you can, and we don't have to poke holes into our `Menu` component just to meet every use case that pops up.\n\nAlmost.\n\nWhat if we need to put a div around one of the items?\n\n```jsx\n<Menu>\n  <div>\n    <MenuItem />\n  </div>\n  <MenuItem />\n</Menu>\n```\n\nThis is totally broken now because we cloned the `div`, not the `MenuItem`. You _could_ recurse down the tree and type check until you find a `MenuItem`, but…come on.\n\nA recursive type check could help a little, but it still limits composition, what if you wanted to do this?\n\n```jsx\nfunction BlueItem(props) {\n  return <MenuItem {...props} className=\"bg-blue\" />;\n}\n\n<Menu>\n  <MenuItem />\n  <BlueItem />\n</Menu>;\n```\n\nThe type checking will fail 😭.\n\nSo now we need a way to define arbitrary components as a `MenuItem`. One workaround is a static property of the component to check instead of just `type`. The type checking changes from this `element.type === MenuItem` to this: `element.type.is === MenuItem`, and of course make sure apps assign `BlueItem.is = MenuItem`.\n\n## Our solution (for now): Descendants context registration\n\nThe `descendants` package provides these key tools:\n\n- `createDescendantContext`: Creates a special context object to deal with registering descendants in a tree (accepts a name string for better debugging)\n- `useDescendants`: A hook to create a state object containing a descendants array and setter function.\n- `DescendantProvider`: A provider that accepts the descendants array, the state setter, and the component's context object for use at the top of the component tree\n- `useDescendant`: A hook called in the body of a nested descendant component that registers its DOM node and returns its index relative to other descendants in the tree\n\n```jsx\nimport {\n  createDescendantContext,\n  DescendantProvider,\n  useDescendant,\n  useDescendants,\n} from \"@reach/descendants\";\n\nlet DescendantContext = createDescendantContext(\"DescendantContext\");\nlet MenuContext = createContext();\n\nfunction Menu({ id, children }) {\n  // We could be less explicit here and set this up in the DescendantProvider,\n  // but you may want to do something with `descendants` in your top-level\n  // component and we don't want to force creating an arbitrary child\n  // component just so we can consume the context.\n  let [descendants, setDescendants] = useDescendantsInit();\n  let [activeIndex, setActiveIndex] = useState(-1);\n  return (\n    <DescendantProvider\n      context={DescendantContext}\n      items={descendants}\n      set={setDescendants}\n    >\n      <MenuContext.Provider\n        value={{ buttonId: `button-${useId(id)}`, activeIndex, setActiveIndex }}\n      >\n        {children}\n      </MenuContext.Provider>\n    </DescendantProvider>\n  );\n}\n\nfunction MenuList(props) {\n  let { buttonId, activeIndex } = useContext(MenuContext);\n  return (\n    <Popover>\n      <div\n        role=\"menu\"\n        aria-labelledby={buttonId}\n        aria-activedescendant={activeIndex}\n        tabIndex={-1}\n      >\n        {children}\n      </div>\n    </Popover>\n  );\n}\n\nfunction MenuItem({ index: explicitIndex, ...props }) {\n  let { activeIndex, setActiveIndex } = useContext(MenuContext);\n  let ref = useRef(null);\n  let index = useDescendant(\n    {\n      // Assign the DOM node using a ref\n      element: ref.current,\n      // You can pass arbitrary data into a descendant object which can come\n      // in handy for features like typeahead!\n      key: props.label,\n    },\n    // Tell the useDescendant hook to use a specific context.\n    // This is key in case you have a compound component that needs index\n    // tracking in separate correlating descendant components (like `Tabs`)\n    DescendantContext,\n    // If you want to declare a specific index value, you can pass it as the\n    // third argument here. This is almost never needed but we provide it as an\n    // escape hatch for special circumstances.\n    explicitIndex\n  );\n\n  // Now we know the index, so let's use it!\n  let isSelected = index === activeIndex;\n  function select() {\n    if (!isSelected) {\n      setActiveIndex(index);\n    }\n  }\n\n  return (\n    <div\n      role=\"menuitem\"\n      ref={ref}\n      data-selected={isSelected ? \"\" : undefined}\n      tabIndex={-1}\n      onMouseEnter={select}\n      {...props}\n    />\n  );\n}\n```\n\nYou can also access the descendants object anywhere in the tree (below the top-level component) with `useDescendants`:\n\n```jsx\nlet menuItems = useDescendants(DescendantContext);\n```\n\nThe key tradeoff here is that descendants won't be available on the first render, and as such any components that need this data for server-side rendering will need to manage their own state and pass descendant data from from the top of the tree. For example\n\n```jsx\nfunction Comp() {\n  <Listbox>\n    {/*\n    The button needs to know which value is selected to render its label!\n    The label will be empty on the server if we depend on descendant hooks\n    */}\n    <ListboxButton />\n    <ListboxList>\n      <ListboxOption value=\"Apple\" />\n      <ListboxOption value=\"Orange\" />\n      <ListboxOption value=\"Banana\" />\n    </ListboxList>\n  </Listbox>;\n}\n\nfunction CompSSR() {\n  // This limits composition, but now you have your data in one place at the top\n  let options = [\"Apple\", \"Orange\", \"Banana\"];\n  let [activeOption, setActiveOption] = useState(options[0]);\n  <Listbox onChange={setActiveOption} selected={activeOption}>\n    {/* The button needs to know which value is selected to render its label! */}\n    <ListboxButton>{activeOption}</ListboxButton>\n    <ListboxList>\n      {options.map((option) => (\n        <ListboxOption value={option} key={option} />\n      ))}\n    </ListboxList>\n  </Listbox>;\n}\n\nfunction ComposableSSR() {\n  // You can manage state at the top and still get back some composition, you'll\n  // just have to deal with a bit of repitition\n  let [activeOption, setActiveOption] = useState(\"Apple\");\n  <Listbox onChange={setActiveOption} selected={activeOption}>\n    {/* The button needs to know which value is selected to render its label! */}\n    <ListboxButton>{activeOption}</ListboxButton>\n    <ListboxList>\n      <ListboxOption value=\"Apple\">\n        Apple <span aria-hidden>🍎</span>\n      </ListboxOption>\n      <ListboxOption\n        value=\"Orange\"\n        aria-labelledby=\"orange-label\"\n        aria-describedby=\"orange-description\"\n      >\n        <span id=\"orange-label\">\n          Orange <span aria-hidden>🍊</span>\n        </span>\n        <span id=\"orange-description\">Fun fact: Oranges are delicious!</span>\n      </ListboxOption>\n      <ListboxOption value=\"Banana\">\n        Banana <span aria-hidden>🍌</span>\n      </ListboxOption>\n    </ListboxList>\n  </Listbox>;\n}\n```\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2018-present, React Training LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@reach/descendants/-/descendants-0.10.5.tgz#2611174e9e9b326dba548356221e2f8c8f5c8612",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@reach/descendants/-/descendants-0.10.5.tgz",
    "hash": "2611174e9e9b326dba548356221e2f8c8f5c8612",
    "integrity": "sha512-8HhN4DwS/HsPQ+Ym/Ft/XJ1spXBYdE8hqpnbYR9UcU7Nx3oDbTIdhjA6JXXt23t5avYIx2jRa8YHCtVKSHuiwA==",
    "registry": "npm",
    "packageName": "@reach/descendants",
    "cacheIntegrity": "sha512-8HhN4DwS/HsPQ+Ym/Ft/XJ1spXBYdE8hqpnbYR9UcU7Nx3oDbTIdhjA6JXXt23t5avYIx2jRa8YHCtVKSHuiwA== sha1-JhEXTp6bMm26VINWIh4vjI9chhI="
  },
  "registry": "npm",
  "hash": "2611174e9e9b326dba548356221e2f8c8f5c8612"
}