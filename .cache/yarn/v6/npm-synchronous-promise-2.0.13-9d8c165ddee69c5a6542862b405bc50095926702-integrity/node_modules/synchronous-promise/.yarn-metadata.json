{
  "manifest": {
    "name": "synchronous-promise",
    "version": "2.0.13",
    "description": "Synchronous Promise-like prototype to use in testing where you would have used an ES6 Promise",
    "main": "index.js",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/fluffynuts/synchronous-promise.git"
    },
    "scripts": {
      "preautotest-once": "node -e \"console.log('Tests started: ', new Date());\"",
      "autotest-once": "mocha index.spec.js --reporter mocha-yar",
      "autotest": "nodemon -q -x \"run-s -s autotest-once\"",
      "autolint": "nodemon -q -x \"run-s -s lint\"",
      "prelint": "node -e \"console.log('Linting started: ', new Date());\"",
      "lint": "jshint index.js",
      "postlint": "node -e \"console.log('Linting completed: ', new Date());\"",
      "pretest": "run-s lint",
      "test-js": "mocha index.spec.js",
      "test": "run-s test-js test-ts",
      "predist": "mkdirp dist",
      "dist": "browserify browser.js -o dist/synchronous-promise.js",
      "prepublish": "run-s -s test dist",
      "debug": "mocha -w *.spec.js --reporter mocha-yar --debug-brk --inspect",
      "debug-ts": "mocha -r ts-node/register *.spec.ts --debug-brk --inspect",
      "preautotest-ts-once": "node -e \"console.log('TS Tests started: ', new Date());\"",
      "autotest-ts": "nodemon -q -e ts -x \"run-s -s test-ts\"",
      "test-ts": "mocha -r ts-node/register *.spec.ts --reporter mocha-yar",
      "tsc": "tsc",
      "test-emitted": "mocha index-ts.spec.js",
      "debug-emitted": "mocha index-ts.spec.js --debug-brk --inspect"
    },
    "author": {
      "name": "Davyd McColl",
      "email": "davydm@gmail.com",
      "url": "https://github.com/fluffynuts"
    },
    "license": "BSD-3-Clause",
    "devDependencies": {
      "@types/chai": "^4.1.5",
      "@types/mocha": "^2.2.44",
      "@types/node": "^8.10.30",
      "browserify": "^14.5.0",
      "chai": "^4.1.2",
      "jshint": "^2.9.6",
      "mkdirp": "^0.5.1",
      "mocha": "^4.0.1",
      "mocha-yar": "^1.0.13",
      "nodemon": "^1.18.4",
      "npm-run-all": "^4.1.2",
      "run-sequence": "^2.2.0",
      "ts-node": "^3.3.0",
      "typescript": "^2.9.2"
    },
    "_registry": "npm",
    "_loc": "/home/senmioxl/.cache/yarn/v6/npm-synchronous-promise-2.0.13-9d8c165ddee69c5a6542862b405bc50095926702-integrity/node_modules/synchronous-promise/package.json",
    "readmeFilename": "README.md",
    "readme": "# synchronous-promise\nTL;DR: A prototypical animal which looks like an A+ Promise but doesn't defer\nimmediately, so can run synchronously, for testing. Technically, this makes it\n*not* A+ compliant, since part of the A+ spec is that resolution be asynchronous.\n\nThis means that I unfortunately can't run the official tests at [https://github.com/promises-aplus/promises-tests](https://github.com/promises-aplus/promises-tests). As such, I rely on issue reports from users and welcome contributions.\n\n![Build and Test](https://github.com/fluffynuts/synchronous-promise/workflows/Tests/badge.svg)\n\n### Why?\nThe standard ES6 Promise (and any others which *are* A+ compliant) push the promise logic to the background\nimmediately, departing from the mechanisms employed in years past by promise\nimplementations in libraries such as jQuery and Q.\n\nThis is a good thing -- for production code. But it can make testing more\nconvoluted than it really needs to be.\n\nOften, in a test, we're stubbing out a function which would return a promise\n(eg http call, show a modal dialog requiring user interaction) with a promise\nthat resolves immediately, eg (using, mocha/sinon/chai):\n\n```javascript\ndescribe('the thing', () => {\n  it('will do some stuff', () => {\n    // Arrange\n    const asyncLibraryFake = {\n      someMethod: sinon.stub().returns(Promise.resolve('happy value!'))\n    },\n    sut = createSystemUnderTestWith(asyncLibraryFake);\n    // Act\n    sut.doSomethingInteresting();\n    // Assert\n    //  [*]\n  })\n});\n```\n\n[*] Ideally, we'd just have assertions here, but the code above has backgrounded,\nso we're not going to get our expected results unless we employ async testing\nstrategies ourselves.\n\nOne strategy would be to return the promise from\n  asyncLibraryFake.someMethod\nfrom the\n  doSomethingInteresting\nfunction and perform our asserts in there:\n\n```javascript\ndescribe('the thing', () => {\n  it('will do some stuff', done => {\n    // Arrange\n    const asyncLibraryFake = {\n      someMethod: sinon.stub().returns(Promise.resolve('happy value!'))\n    },\n    sut = createSystemUnderTestWith(asyncLibraryFake);\n    // Act\n    sut.doSomethingInteresting().then(() => {\n      // Assert\n      done()\n    });\n  })\n});\n```\n***And there's nothing wrong with this strategy.***\n\nI need to put that out there before anyone takes offense or thinks that I'm suggesting\nthat they're \"doing it wrong\".\nIf you're doing this (or something very similar), great; `async/await`, if available,\ncan make this code quite clean and linear too.\n\nHowever, when we're working on more complex interactions, eg when we're not\ntesting the final result of a promise chain, but rather testing a side-effect\nat some step during that promise chain, this can become more effort to test\n(and, imo, make your testing more unclear).\n\nMany moons ago, using, for example, Q, we could create a deferred object with\n`Q.defer()` and then resolve or reject ith with `deferred.resolve()` and\n`deferred.reject()`. Since there was no initial backgrounding, we could set\nup a test with an unresolved promise, make some pre-assertions, then resolve\nand make assertions about \"after resolution\" state, without making our tests\nasync at all. It made testing a little easier (imo) and the idea has been\npropagated into frameworks like `angular-mocks`\n\n### Usage\n\nSynchronousPromise looks (from the outside) a lot like an ES6 promise. We construct\nthe same:\n\n```javascript\nvar promise = new SynchronousPromise((resolve, reject) => {\n  if (Math.random() < 0.1) {\n    reject('unlucky!');\n  } else {\n    resolve('lucky!');\n  }\n});\n```\n\nThey can, of course, be chained:\n\n```javascript\nvar initial = new SynchronousPromise((resolve, reject) => {\n  resolve('happy!');\n});\ninitial.then(message => {\n  console.log(message);\n})\n```\n\nAnd have error handling, either from the basic A+ spec:\n\n```javascript\ninitial.then(message => {\n  console.log(message);\n}, error => {\n  console.error(error);\n});\n```\n\nOr using the more familiar `catch()`:\n\n```javascript\ninitial.then(message => {\n  console.log(message);\n}).catch(error => {\n  console.error(error);\n})\n```\n\n`.catch()` starts a new promise chain, so you can pick up with new logic\nif you want to. `.then()` can deal with returning raw values or promises\n(as per A+)\n\n`SynchronousPromise` also supports `.finally()` as of version 2.0.8.\n\n### Statics\n`.all()`, `.resolve()` and `.reject()` are available on the `SynchronousPromise`\nobject itself:\n\n```javascript\nSynchronousPromise.all([p1, p2]).then(results => {\n  // results is an array of results from all promises\n}).catch(err => {\n  // err is any single error thrown by a promise in the array\n});\n\nSynchronousPromise.resolve('foo');  // creates an already-resolved promise\n\nSynchronousPromise.reject('bar'); // creats an already-rejected promise\n```\n\n(`race()` isn't because I haven't determined a good strategy for that yet,\nconsidering the synchronous design goal -- but it's\nunlikely you'll need `race()` from a test).\n\n### Extras\n`SynchronousPromise` also provides two extra functions to make testing a little\neasier:\n\n#### Static methods\nThe `unresolved()` method returns a new, unresolved `SynchronousPromise` with\nthe constructor-function-provided `resolve` and `reject` functions attached as properties.\nUse this when you have no intention of resolving or rejecting the promise or when you\nwant to resolve or reject at some later date.\n\n```javascript\nvar\n  resolvedValue,\n  rejectedValue,\n  promise = SynchronousPromise.unresolved().then(function(data) {\n    resolved = data;\n  }).catch(function(data) {\n    rejected = data;\n  });\n  // at this point, resolved and rejected are both undefined\n\n  // ... some time later ...\n  if (Math.random() > 0.5) {\n    promise.resolve(\"yay\");\n    // now resolvedValue is \"yay\" and rejectedValue is still undefined\n  } else {\n    promise.reject(\"boo\");\n    // now rejectedValue is \"boo\" and resolvedValue is still undefined\n  }\n```\n\n#### Instance methods\n\n`pause()` pauses the promise chain at the point at which it is called:\n\n```javascript\nSynchronousPromise.resolve('abc').then(data => {\n  // this will be run\n  return '123';\n}).pause().then(data2 => {\n  // we don't get here without resuming\n});\n```\n\nand `resume()` resumes operations:\n\n```javascript\nvar\n  promise = SynchronousPromise.resolve('123').pause(),\n  captured = null;\npromise.then(data => {\n  captured = data;\n});\n\nexpect(captured).to.be.null;   // because we paused...\npromise.resume();\nexpect(captured).to.equal('123'); // because we resumed...\n```\n\nYou can use `pause()` and `resume()` to test the state of your system under\ntest at defined points in a series of promise chains\n\n### ES5\nSynchronousPromise is purposefully written with prototypical, ES5 syntax so you\ncan use it from ES5 if you like. Use the `synchronous-promise.js` file from the\n`dist` folder if you'd like to include it in a browser environment (eg karma).\n\n## Typescript\nThe `synchronous-promise` package includes an `index.d.ts`. To install, run:\n```\ntypings install npm:synchronous-promise --save\n```\n*On any modern TypeScript (v2+), you shouldn't need to do this.*\n\nAlso note that TypeScript does async/await cleverly, treating all promises\nequally, such that `await` will work just fine against a SynchronousPromise -- it just won't be backgrounded.\n\n**HOWEVER:** there is a _very specific_ way that SynchronousPromise\ncan interfere with TypeScript: if\n- SynchronousPromise is installed globally (ie, overriding the\n  native `Promise` implementation) and\n- You create a SynchronousPromise which is resolved asynchronously,\n  eg:\n\n```js\nglobal.Promise = SynchronousPromise;\nawait new SynchronousPromise((resolve, reject) => {\n  setTimeout(() => resolve(), 0);\n}); // this will hang\n```\n\nThis is due to how TypeScript generates the `__awaiter` function\nwhich is `yielded` to provide `async`/`await` functionality, in\nparticular that the emitted code assumes that the global `Promise`\nwill _always be asynchronous_, which is normally a reasonable assumption.\n\nInstalling SynchronousPromise globally may be a useful testing tactic,\nwhich I've used in the past, but I've seen this exact issue crop up\nin production code. `SynchronousPromise` therefor also provides two methods:\n\n- `installGlobally`\n- `uninstallGlobally`\n\nwhich can be used if your testing would be suited to having `Promise` globally\noverridden by `SynchronousPromise`. This needs to get the locally-available `__awaiter` and the result (enclosed with a reference to the real `Promise`)\nmust override that `__awaiter`, eg:\n\n```ts\ndeclare var __awaiter: Function;\nbeforeEach(() => {\n  __awaiter = SynchronousPromise.installGlobally(__awaiter);\n});\nafterEach(() => {\n  SynchronousPromise.uninstallGlobally();\n});\n```\n\nIt's not elegant that client code needs to know about the transpiled\ncode, but this works.\n\nI have an issue open on GitHub\n[https://github.com/Microsoft/TypeScript/issues/19909](https://github.com/Microsoft/TypeScript/issues/19909)\nbut discussion so far has not beein particularly convincing that\nTypeScript emission will be altered to (imo) a more robust\nimplementation which wraps the emitted `__awaiter` in a closure.\n\n\n### Production code\nThe main aim of SynchronousPromise is to facilitate easier testing. That being\nsaid, it appears to conform to expected `Promise` behaviour, barring the\nalways-backgrounded behaviour. One might be tempted to just use it everywhere.\n\n**However**: I'd highly recommend using *any* of the more venerable promise implementations\ninstead of SynchronousPromise in your production code -- preferably the vanilla\nES6 Promise, where possible (or the shim, where you're in ES5). Or Q.\nOr jQUery.Deferred(), Bluebird or any of the implementations at [https://promisesaplus.com/implementations](https://promisesaplus.com/implementations).\n\nBasically, this seems to work quite well for testing and\nI've tried to implement every behaviour I'd expect from a promise -- but I'm\npretty sure that a native `Promise` will be better for production code any day.\n",
    "licenseText": "Copyright (c) 2016, Davyd McColl\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of synchronous-promise nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/synchronous-promise/-/synchronous-promise-2.0.13.tgz#9d8c165ddee69c5a6542862b405bc50095926702",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/synchronous-promise/-/synchronous-promise-2.0.13.tgz",
    "hash": "9d8c165ddee69c5a6542862b405bc50095926702",
    "integrity": "sha512-R9N6uDkVsghHePKh1TEqbnLddO2IY25OcsksyFp/qBe7XYd0PVbKEWxhcdMhpLzE1I6skj5l4aEZ3CRxcbArlA==",
    "registry": "npm",
    "packageName": "synchronous-promise",
    "cacheIntegrity": "sha512-R9N6uDkVsghHePKh1TEqbnLddO2IY25OcsksyFp/qBe7XYd0PVbKEWxhcdMhpLzE1I6skj5l4aEZ3CRxcbArlA== sha1-nYwWXd7mnFplQoYrQFvFAJWSZwI="
  },
  "registry": "npm",
  "hash": "9d8c165ddee69c5a6542862b405bc50095926702"
}